diff --git a/.gitignore b/.gitignore
index 2b9af51..2d3fefa 100644
--- a/.gitignore
+++ b/.gitignore
@@ -54,3 +54,4 @@ __pycache__/
 *.pack
 *.idx
 
+docker-compose/images/*.tar
diff --git a/orchestrator/build.sh b/docker-compose/build.sh
similarity index 53%
rename from orchestrator/build.sh
rename to docker-compose/build.sh
index f12b142..2bfb1fe 100644
--- a/orchestrator/build.sh
+++ b/docker-compose/build.sh
@@ -1,24 +1,29 @@
 #!/bin/bash -e
 
+# Create images directory if it doesn't exist
+mkdir -p images
+
 # Export version as an environment variable
 export VERSION=v1.0.20  # You can change this value to any version you want
 
 # Build the Docker image with the version tag
+cd ../orchestrator
 docker build -t randao/orchestrator:latest -t randao/orchestrator:$VERSION .
-
-# Log in to Docker
-docker login
-
-# Push the image with the version tag
-docker push randao/orchestrator:latest
-docker push randao/orchestrator:$VERSION
+cd ../docker-compose
 
 # Create and use buildx builder
 docker buildx create --use
 docker buildx inspect --bootstrap
 
-# Build the multi-platform image and push it
+# Build the multi-platform image
 docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7 \
 -t randao/orchestrator:latest \
 -t randao/orchestrator:$VERSION \
---push .
\ No newline at end of file
+--load ../orchestrator
+
+# Save the images
+echo "Saving images to images directory..."
+docker save postgres:13-alpine > images/postgres-13-alpine.tar
+docker save randao/orchestrator:latest > images/orchestrator-latest.tar
+
+echo "Build and packaging complete. Images saved to images directory."
diff --git a/docker-compose/docker-compose.yml b/docker-compose/docker-compose.yml
index 840ca38..0abdb26 100644
--- a/docker-compose/docker-compose.yml
+++ b/docker-compose/docker-compose.yml
@@ -25,7 +25,6 @@ services:
 
   orchestrator:
     image: randao/orchestrator:latest
-    pull_policy: always  # Ensure the latest image is always pulled
     restart: unless-stopped  # Restart on crash (or on exit with non-zero code)
     depends_on:
       postgres:
diff --git a/docker-compose/extract.sh b/docker-compose/extract.sh
new file mode 100644
index 0000000..7e9ade7
--- /dev/null
+++ b/docker-compose/extract.sh
@@ -0,0 +1,24 @@
+#!/bin/bash -e
+
+# Check if images directory exists
+if [ ! -d "images" ]; then
+    echo "Error: images directory not found!"
+    exit 1
+fi
+
+# Load the images if they exist
+if [ -f "images/postgres-13-alpine.tar" ]; then
+    echo "Loading postgres image..."
+    docker load < images/postgres-13-alpine.tar
+else
+    echo "Warning: postgres image archive not found"
+fi
+
+if [ -f "images/orchestrator-latest.tar" ]; then
+    echo "Loading orchestrator image..."
+    docker load < images/orchestrator-latest.tar
+else
+    echo "Warning: orchestrator image archive not found"
+fi
+
+echo "Image extraction complete"
diff --git a/orchestrator/package.json b/orchestrator/package.json
index 60b4da3..bd15e61 100644
--- a/orchestrator/package.json
+++ b/orchestrator/package.json
@@ -8,7 +8,7 @@
     "typescript": "^5.6.3"
   },
   "dependencies": {
-    "ao-js-sdk":"^0.2.11",
+    "ao-js-sdk": "0.2.20",
     "ao-vrf": "file:",
     "arweave": "^1.15.5",
     "aws-sdk": "^2.1692.0",
diff --git a/orchestrator/src/app.ts b/orchestrator/src/app.ts
index 949f87f..5707a09 100644
--- a/orchestrator/src/app.ts
+++ b/orchestrator/src/app.ts
@@ -6,7 +6,7 @@ import { checkAndFetchIfNeeded, cleanupFulfilledEntries, crank, getProviderReque
 import logger, { LogLevel, Logger } from './logger';
 import { monitoring } from './monitoring';
 
-export const VERSION = "1.0.18";
+export const VERSION = "1.0.20";
 
 export const docker = new Docker();
 export const DOCKER_NETWORK = process.env.DOCKER_NETWORK || "backend";
@@ -63,7 +63,7 @@ function getLogId(): string {
     return `[LogID: ${randomId} | ${timestamp}]`;
 }
 
-async function polling(client: any) {
+async function polling(client: any, randomClient: any) {
     if (pollingInProgress) {
         const completedSteps = Object.entries(stepTracking)
             .filter(([_, data]) => data?.completed)
@@ -71,18 +71,17 @@ async function polling(client: any) {
 
         logger.debug(`\n[SKIPPED] Polling already in progress for ${lastPollingId}. Skipping this run.`);
         logger.debug(`Completed steps so far: ${completedSteps.length > 0 ? completedSteps.join(", ") : "None"}`);
-        logger.verbose("Current step tracking status:", stepTracking); // Debugging info to inspect tracking object
-        return; // Prevent concurrent execution
+        return;
     }
 
-    resetStepTracking(); // Reset step tracking for fresh polling
-    pollingInProgress = true; // Mark polling as in progress
+    resetStepTracking();
+    pollingInProgress = true;
     const logId = getLogId();
     lastPollingId = logId;
     logger.info(`${logId} Starting Polling...`);
 
     try {
-        const startTime = Date.now(); // Start time of polling
+        const startTime = Date.now();
 
         // Step 1: Fetch open requests
         const s1 = Date.now();
@@ -90,11 +89,10 @@ async function polling(client: any) {
         const openRequests = await getProviderRequests(PROVIDER_ID, logId);
         const timeTaken = Date.now() - s1;
         stepTracking.step1 = { completed: true, timeTaken };
-        // Update monitoring with step timing
         monitoring.updateStepTiming('step1', timeTaken);
         logger.debug(`${logId} Step 1: Open requests fetched. Time taken: ${stepTracking.step1.timeTaken}ms`);
 
-        // Run Step 2, 3, and 4 concurrently
+        // Run Steps 2, 3, and 4 concurrently
         await Promise.all([
             (async () => {
                 const s2 = Date.now();
@@ -102,7 +100,6 @@ async function polling(client: any) {
                 await processChallengeRequests(client, openRequests.activeChallengeRequests, logId);
                 const timeTaken = Date.now() - s2;
                 stepTracking.step2 = { completed: true, timeTaken };
-                // Update monitoring with step timing
                 monitoring.updateStepTiming('step2', timeTaken);
                 logger.debug(`${logId} Step 2 completed. Time taken: ${stepTracking.step2.timeTaken}ms`);
             })(),
@@ -112,124 +109,86 @@ async function polling(client: any) {
                 await processOutputRequests(client, openRequests.activeOutputRequests, logId);
                 const timeTaken = Date.now() - s3;
                 stepTracking.step3 = { completed: true, timeTaken };
-                // Update monitoring with step timing
                 monitoring.updateStepTiming('step3', timeTaken);
                 logger.debug(`${logId} Step 3 completed. Time taken: ${stepTracking.step3.timeTaken}ms`);
             })(),
             (async () => {
                 const s4 = Date.now();
                 logger.debug(`${logId} Step 4 started.`);
-                //TODO enable this again later
                 await cleanupFulfilledEntries(client, openRequests, logId);
-                await checkAndFetchIfNeeded(client)
-
-                crank(); //TODO find a better place for this
+                await checkAndFetchIfNeeded(client);
+                crank();
                 
                 const timeTaken = Date.now() - s4;
                 stepTracking.step4 = { completed: true, timeTaken };
-                // Update monitoring with step timing
                 monitoring.updateStepTiming('step4', timeTaken);
                 logger.debug(`${logId} Step 4 completed. Time taken: ${stepTracking.step4.timeTaken}ms`);
             })(),
         ]);
 
         const totalTime = Date.now() - startTime;
-        // Update overall step timing in monitoring
         monitoring.updateStepTiming('overall', totalTime);
         logger.info(`${logId} Polling cycle completed successfully. Total time taken: ${totalTime}ms`);
 
     } catch (error) {
         logger.error(`${logId} An error occurred during polling:`, error);
-        // Increment error count in monitoring
         monitoring.incrementErrorCount();
     } finally {
-        pollingInProgress = false; // Reset flag after execution
+        pollingInProgress = false;
     }
 }
 
 // Main function
 async function run(): Promise<void> {
+    Logger.setLogLevel(LogLevel.DEBUG);
     logger.info("Orchestrator starting up");
     
-    // Ensure wallet configuration exists, generate if needed
-    logger.info("Step 1/4: Ensuring wallet configuration...");
+    // Step 1: Ensure wallet configuration
+    console.log("[INIT] Step 1/4: Ensuring wallet configuration...");
     await ensureWalletConfiguration();
-    logger.info("Step 1/4: Wallet configuration complete");
+    console.log("[INIT] Step 1/4: ‚úì Wallet configuration complete");
     
-    logger.info("Step 2/4: Initializing database services...");
+    // Step 2: Initialize database
+    console.log("[INIT] Step 2/4: Initializing database services...");
     const client = await connectWithRetry();
     await setupDatabase(client);
-    logger.info("Step 2/4: Database services initialized");
+    console.log("[INIT] Step 2/4: ‚úì Database services initialized");
 
-    // Initialize wallet and set provider ID using wallet utilities
-    logger.info("Step 3/4: Initializing wallet and provider ID...");
-    try {
-        logger.info("Step 3a/4: Checking wallet configuration sources...");
-        const stepStart = Date.now();
-        
-        // This will internally handle wallet initialization from seed phrase or JSON
-        logger.info("Step 3b/4: Initializing wallet from configuration...");
-        const walletInitStart = Date.now();
-        const address = await getWalletAddress();
-        logger.info(`Step 3b/4: Wallet initialization complete (${Date.now() - walletInitStart}ms)`);
-        
-        logger.info("Step 3c/4: Setting provider ID from wallet address...");
-        const providerIdStart = Date.now();
-        PROVIDER_ID = address;
-        logger.info(`Step 3c/4: Provider ID set: ${address} (${Date.now() - providerIdStart}ms)`);
-        
-        logger.info("Step 3d/4: Validating provider ID configuration...");
-        const validationStart = Date.now();
-        if (!PROVIDER_ID || PROVIDER_ID.length === 0) {
-            throw new Error('Provider ID is empty or invalid');
-        }
-        logger.info(`Step 3d/4: Provider ID validation complete (${Date.now() - validationStart}ms)`);
-        
-        logger.info(`Step 3/4: Wallet and provider ID initialization complete (Total: ${Date.now() - stepStart}ms)`);
-    } catch (error) {
-        logger.error('Failed to initialize wallet and provider ID:', error);
-        process.exit(1);
-    }
+    // Step 3: Get provider ID
+    console.log("[INIT] Step 3/4: Getting provider ID...");
+    PROVIDER_ID = await getWalletAddress();
+    console.log(`[INIT] Step 3/4: ‚úì Provider ID ready: ${PROVIDER_ID}`);
     
-    // Initialize random client before starting main operations
-    logger.info("Step 4/4: Initializing random client (CRITICAL - must complete before operations)...");
-    try {
-        const randomClient = await getRandomClient();
-        logger.info("Step 4/4: Random client initialization complete - system ready for operations");
-        logger.info("=== ORCHESTRATOR STARTUP COMPLETE ===");
-    } catch (error) {
-        logger.error('CRITICAL: Failed to initialize random client during startup:', error);
-        logger.error('System cannot proceed without random client - shutting down');
-        process.exit(1);
-    }
+    // Step 4: Initialize random client
+    console.log("[INIT] Step 4/4: Initializing random client...");
+    let randomClient = await getRandomClient();
+    console.log("[INIT] Step 4/4: ‚úì Random client initialization complete");
+    console.log("[INIT] üöÄ === ORCHESTRATOR STARTUP COMPLETE ===");
 
-    // Handle graceful shutdown before entering infinite loop
+    // Setup graceful shutdown
     process.on("SIGTERM", async () => {
         logger.info("SIGTERM received. Shutting down gracefully.");
         await client.end();
         await gracefulShutdown();
         for (let i = 0; i < SHUTDOWN_POLLING_DELAY; i++) {
             try {
-                await polling(client);
+                await polling(client, randomClient);
             } catch (error) {
                 logger.error(`Shutdown Polling iteration ${i + 1} failed:`, error);
             }
         }
-        await Logger.close(); // Use the static close method on the Logger class
+        await Logger.close();
         process.exit(0);
     });
-    //TODO SEE WHATS BETTER (This could possibly have a new tx queed up while the old one is in the works to keep it speeds but who knows)
-    // setInterval(async () => {
-    //     await polling(client);
-    // }, POLLING_INTERVAL_MS);
 
-    // Infinite polling loop with maintenance
+    // Main polling loop with maintenance
     while (true) {
         try {
             const currentTime = Date.now();
             
-            // Regular polling
-            await polling(client);
+            // Get fresh random client and poll
+            randomClient = await getRandomClient();
+            await polling(client, randomClient);
             
             // Database maintenance every 10 minutes
             if (currentTime - lastMaintenanceTime >= DATABASE_MAINTENANCE_INTERVAL) {
diff --git a/orchestrator/src/db_tools.ts b/orchestrator/src/db_tools.ts
index 14668fc..16d6959 100644
--- a/orchestrator/src/db_tools.ts
+++ b/orchestrator/src/db_tools.ts
@@ -137,3 +137,188 @@ export async function performAggressiveCleanup(client: Client): Promise<void> {
         logger.error("‚ùå Error during aggressive cleanup:", error.message);
     }
 }
+
+// Get count of usable database entries
+export async function getUsableEntriesCount(client: Client): Promise<number> {
+    const res = await client.query(
+        'SELECT COUNT(*) AS count FROM time_lock_puzzles WHERE request_id IS NULL'
+    );
+    return parseInt(res.rows[0].count, 10);
+}
+
+// Assign request IDs to available database entries
+export async function assignRequestIdsToEntries(
+    client: Client, 
+    requestIds: string[]
+): Promise<{ requestId: string, dbId: string }[]> {
+    await client.query('BEGIN');
+    
+    try {
+        // Fetch already assigned request_id -> dbId mappings
+        const existingMappingsRes = await client.query(
+            `SELECT request_id FROM time_lock_puzzles 
+             WHERE request_id = ANY($1) 
+             FOR UPDATE SKIP LOCKED`,
+            [requestIds]
+        );
+
+        const existingRequestIds = new Set(existingMappingsRes.rows.map(row => row.request_id));
+        const unmappedRequestIds = requestIds.filter(requestId => !existingRequestIds.has(requestId));
+        
+        let mappedEntries: { requestId: string, dbId: string }[] = [];
+
+        if (unmappedRequestIds.length > 0) {
+            const dbRes = await client.query(
+                `SELECT id FROM time_lock_puzzles 
+                 WHERE request_id IS NULL 
+                 ORDER BY id ASC 
+                 LIMIT $1 
+                 FOR UPDATE SKIP LOCKED`,
+                [unmappedRequestIds.length]
+            );
+
+            const availableDbEntries = dbRes.rows.map(row => row.id);
+
+            if (availableDbEntries.length > 0) {
+                const numMappings = Math.min(unmappedRequestIds.length, availableDbEntries.length);
+
+                for (let i = 0; i < numMappings; i++) {
+                    await client.query(
+                        `UPDATE time_lock_puzzles 
+                         SET request_id = $1 
+                         WHERE id = $2`,
+                        [unmappedRequestIds[i], availableDbEntries[i]]
+                    );
+                    mappedEntries.push({ requestId: unmappedRequestIds[i], dbId: availableDbEntries[i] });
+                }
+            }
+        }
+
+        await client.query('COMMIT');
+        return [...Array.from(existingRequestIds).map(id => ({ requestId: id, dbId: '' })), ...mappedEntries];
+        
+    } catch (error) {
+        await client.query('ROLLBACK');
+        throw error;
+    }
+}
+
+// Get puzzle data for challenge fulfillment
+export async function getPuzzleDataForChallenge(client: Client, requestId: string): Promise<{
+    id: string;
+    modulus: string;
+    x: string;
+} | null> {
+    const res = await client.query(
+        `SELECT id, modulus, x 
+         FROM time_lock_puzzles 
+         WHERE request_id = $1`,
+        [requestId]
+    );
+
+    if (!res.rowCount) {
+        return null;
+    }
+
+    return res.rows[0];
+}
+
+// Get puzzle data for output fulfillment
+export async function getPuzzleDataForOutput(client: Client, requestId: string): Promise<{
+    id: string;
+    output: string;
+    rsaP: string;
+    rsaQ: string;
+} | null> {
+    const res = await client.query(
+        `SELECT 
+            tlp.id, 
+            tlp.y AS output, 
+            rk.p AS rsaP, 
+            rk.q AS rsaQ 
+        FROM time_lock_puzzles tlp
+        JOIN rsa_keys rk ON tlp.rsa_id = rk.id
+        WHERE tlp.request_id = $1`,
+        [requestId]
+    );
+
+    if (!res.rowCount) {
+        return null;
+    }
+
+    return res.rows[0];
+}
+
+// Clean up fulfilled entries that are no longer in use
+export async function cleanupFulfilledEntriesAdvanced(
+    client: Client,
+    activeChallengeRequestIds: string[],
+    activeOutputRequestIds: string[],
+    retentionPeriodMs: number
+): Promise<{ markedCompleted: number, deleted: number }> {
+    const now = new Date();
+    const cutoffTime = new Date(now.getTime() - retentionPeriodMs);
+
+    try {
+        await client.query('BEGIN');
+
+        // Fetch all entries with a request_id
+        const result = await client.query(`
+            SELECT id, request_id, detected_completed 
+            FROM time_lock_puzzles 
+            WHERE request_id IS NOT NULL
+        `);
+
+        let markForDeletion: string[] = [];
+        let markAsCompleted: string[] = [];
+
+        for (const row of result.rows) {
+            const { id, request_id, detected_completed } = row;
+
+            // Check if this request is still active in challenge or output
+            const isStillInChallenge = activeChallengeRequestIds.includes(request_id);
+            const isStillInOutput = activeOutputRequestIds.includes(request_id);
+
+            if (!isStillInChallenge && !isStillInOutput) {
+                if (!detected_completed) {
+                    // Mark it for deletion by setting detected_completed timestamp
+                    markAsCompleted.push(id);
+                } else if (new Date(detected_completed) < cutoffTime) {
+                    // If already marked and older than retention period, delete it
+                    markForDeletion.push(id);
+                }
+            }
+        }
+
+        // Mark entries as completed
+        if (markAsCompleted.length > 0) {
+            await client.query(`
+                UPDATE time_lock_puzzles
+                SET detected_completed = NOW()
+                WHERE id = ANY($1)
+            `, [markAsCompleted]);
+        }
+
+        // Delete old completed entries 
+        if (markForDeletion.length > 0) {
+            await client.query(`
+                DELETE FROM rsa_keys
+                WHERE id IN (
+                    SELECT rsa_id FROM time_lock_puzzles WHERE id = ANY($1)
+                );
+            `, [markForDeletion]);
+
+            await client.query(`
+                DELETE FROM time_lock_puzzles
+                WHERE id = ANY($1);
+            `, [markForDeletion]);
+        }
+
+        await client.query('COMMIT');
+        return { markedCompleted: markAsCompleted.length, deleted: markForDeletion.length };
+        
+    } catch (error) {
+        await client.query('ROLLBACK');
+        throw error;
+    }
+}
diff --git a/orchestrator/src/helperFunctions.ts b/orchestrator/src/helperFunctions.ts
index ab353e3..f9b119a 100644
--- a/orchestrator/src/helperFunctions.ts
+++ b/orchestrator/src/helperFunctions.ts
@@ -6,30 +6,30 @@ import logger, { LogLevel } from "./logger";
 import { monitoring } from "./monitoring";
 import { setTimeout, setInterval } from 'timers';
 import { getWallet } from "./walletUtils";
+import { getUsableEntriesCount, assignRequestIdsToEntries, getPuzzleDataForChallenge, getPuzzleDataForOutput, cleanupFulfilledEntriesAdvanced } from "./db_tools";
+import * as aoSdkPackage from "ao-js-sdk/package.json";
 
+// Random client management
 let randomClientInstance: RandomClient | null = null;
 let lastInitTime: number = 0;
-const REINIT_INTERVAL = 60 * 1 * 1000; // 1 minute in milliseconds
-let current_onchain_random = - 10
+const REINIT_INTERVAL = 60 * 60 * 1000; // 1 hour
+let current_onchain_random = -10;
 
-// Cooldown tracking for updateAvailableValuesAsync
-let lastUpdatedOnChainTime = 0;
+// Simple flags
+let isInitializing = false;
+let firstInitializationComplete = false;
+let ongoingRandomGeneration = false;
+let initializationPromise: Promise<RandomClient> | null = null;
+
+// Constants
+const MAX_RANDOM_PER_REQUEST = 500;
 const FIFTEEN_MINUTES_MS = 15 * 60 * 1000;
 
-// Cooldown tracking for fulfillRandomChallenge and fulfillRandomOutput (per request ID)
+// Tracking maps
 const challengeCooldowns = new Map<string, boolean>();
 const outputCooldowns = new Map<string, boolean>();
-// Track whether there's an ongoing random generation request
-let ongoingRandomGeneration = false;
-const MAX_RANDOM_PER_REQUEST = 500; // Maximum number of random values to generate in a single request
-
-// Map to track request timestamps
 const requestTimestamps: Map<string, number> = new Map();
-
-let isInitializing = false; // Track if initialization is in progress
-let initPromise: Promise<RandomClient> | null = null; // Store the initialization promise
-let isFirstInitialization = true; // Track if this is the first initialization
-let firstInitializationComplete = false; // Track if first initialization has completed
+let lastUpdatedOnChainTime = 0;
 
 // Function to reset the ongoingRandomGeneration flag
 export function resetOngoingRandomGeneration() {
@@ -38,154 +38,115 @@ export function resetOngoingRandomGeneration() {
 }
 
 export async function getRandomClient(): Promise<RandomClient> {
-    const currentTime = Date.now();
-
-    // For first initialization, always wait for completion
-    if (isFirstInitialization || !firstInitializationComplete) {
-        logger.info('[RandomClient] First initialization required - awaiting completion');
-        return await initializeRandomClientWithLogging(true);
+    // First initialization - must complete
+    if (!firstInitializationComplete) {
+        if (initializationPromise) {
+            return await initializationPromise;
+        }
+        return await initializeRandomClient();
     }
 
-    // Return the existing instance if it's valid and fresh
+    // Return existing client if fresh (less than 1 hour old)
+    const currentTime = Date.now();
     if (randomClientInstance && (currentTime - lastInitTime) <= REINIT_INTERVAL) {
         return randomClientInstance;
     }
 
-    // If reinitialization is already happening, wait for it if it's the first init, otherwise serve old instance
-    if (isInitializing) {
-        if (initPromise) {
-            logger.info('[RandomClient] Reinitialization in progress - awaiting completion');
-            return await initPromise;
-        } else {
-            logger.info('[RandomClient] Reinitialization in progress, serving old instance');
-            return randomClientInstance!;
+    // Handle reinitialization
+    if (isInitializing && initializationPromise) {
+        // Wait for ongoing initialization to complete
+        try {
+            return await initializationPromise;
+        } catch (err) {
+            logger.error('[RandomClient] Failed to wait for reinitialization:', err);
+            // Fall back to old client if available
+            if (randomClientInstance) {
+                return randomClientInstance;
+            }
+            throw err;
         }
     }
 
-    // Start reinitialization (background for subsequent inits)
-    logger.info('[RandomClient] Background reinitialization triggered');
-    return await initializeRandomClientWithLogging(false);
+    // Start new reinitialization if not already happening
+    if (!isInitializing) {
+        initializationPromise = initializeRandomClient();
+        initializationPromise.catch(err => 
+            logger.error('[RandomClient] Background reinitialization failed:', err)
+        );
+        
+        // For background reinitialization, return old client immediately
+        if (randomClientInstance) {
+            return randomClientInstance;
+        }
+        
+        // No old client available, must wait for new one
+        return await initializationPromise;
+    }
+
+    // Should not reach here, but return old client as fallback
+    return randomClientInstance!;
 }
 
 
 /**
- * Initialize the random client with detailed step-by-step logging
- * @param awaitCompletion Whether to await completion or run in background
- * @returns Promise<RandomClient>
+ * Initialize the random client - thread-safe with proper promise handling
  */
-async function initializeRandomClientWithLogging(awaitCompletion: boolean): Promise<RandomClient> {
-    // If already initializing and we need to await, return the existing promise
-    if (isInitializing && initPromise && awaitCompletion) {
-        logger.info('[RandomClient] Initialization already in progress - awaiting existing promise');
-        return await initPromise;
-    }
-
-    // If already initializing but not awaiting, return old instance
-    if (isInitializing && !awaitCompletion && randomClientInstance) {
-        logger.info('[RandomClient] Initialization in progress - serving old instance');
-        return randomClientInstance;
+async function initializeRandomClient(): Promise<RandomClient> {
+    // If already initializing, wait for the existing promise
+    if (isInitializing && initializationPromise) {
+        return await initializationPromise;
     }
 
-    // Start new initialization
     isInitializing = true;
-    const initStartTime = Date.now();
-    const initType = isFirstInitialization ? 'FIRST' : 'REINIT';
-    
-    logger.info(`[RandomClient] Starting ${initType} initialization...`);
+    const isFirst = !firstInitializationComplete;
+    const AO_CONFIG = {
+        MU_URL: "https://ur-mu.randao.net",
+        CU_URL: "https://ur-cu.randao.net",
+        // MU_URL: "https://mu.ao-testnet.xyz",
+        // CU_URL: "https://cu.ao-testnet.xyz",
+        GATEWAY_URL: "https://arweave.net",
+        MODE: "legacy" as const
+    };
     
-    const initializationPromise = (async (): Promise<RandomClient> => {
-        try {
-            // Step 1: Wallet initialization
-            logger.info('[RandomClient] Step 1/4: Initializing wallet configuration...');
-            const stepStart = Date.now();
-            const wallet = await getWallet();
-            logger.info(`[RandomClient] Step 1/4: Wallet configuration complete (${Date.now() - stepStart}ms)`);
-            
-            // Step 2: Client builder initialization
-            logger.info('[RandomClient] Step 2/4: Creating RandomClient builder...');
-            const step2Start = Date.now();
-            const builder = await RandomClient.defaultBuilder();
-            logger.info(`[RandomClient] Step 2/4: RandomClient builder created (${Date.now() - step2Start}ms)`);
-            
-            // Step 3: Configuration setup
-            logger.info('[RandomClient] Step 3/4: Configuring client with wallet and AO settings...');
-            const step3Start = Date.now();
-            const configuredBuilder = builder
-                .withWallet(wallet)
-                .withAOConfig({
-                    CU_URL: process.env.CU_URL || "https://ur-cu.randao.net",
-                    MU_URL: process.env.MU_URL || "https://ur-mu.randao.net",
-                    MODE: "legacy" as const
-                });
-            logger.info(`[RandomClient] Step 3/4: Client configuration complete (${Date.now() - step3Start}ms)`);
-            
-            // Step 4: Build and finalize
-            logger.info('[RandomClient] Step 4/4: Building final RandomClient instance...');
-            const step4Start = Date.now();
-            const newClient = await configuredBuilder.build();
-            logger.info(`[RandomClient] Step 4/4: RandomClient build complete (${Date.now() - step4Start}ms)`);
-            
-            // Finalize initialization
-            randomClientInstance = newClient;
-            lastInitTime = Date.now();
-            
-            if (isFirstInitialization) {
-                firstInitializationComplete = true;
-                isFirstInitialization = false;
-                logger.info(`[RandomClient] FIRST initialization completed successfully! Total time: ${Date.now() - initStartTime}ms`);
-            } else {
-                logger.info(`[RandomClient] Reinitialization completed successfully! Total time: ${Date.now() - initStartTime}ms`);
-            }
-            
-            return newClient;
-            
-        } catch (err) {
-            const errorMsg = `${initType} initialization failed after ${Date.now() - initStartTime}ms`;
-            logger.error(`[RandomClient] ${errorMsg}:`, err);
-            
-            // If this is first initialization and it failed, we need to retry
-            if (isFirstInitialization) {
-                logger.error('[RandomClient] CRITICAL: First initialization failed - system cannot proceed without random client');
-                throw new Error(`Critical random client initialization failure: ${err}`);
-            }
-            
-            throw err;
-        } finally {
-            isInitializing = false;
-            initPromise = null;
+    try {
+        logger.info(`[RandomClient] Using ao-js-sdk version: ${aoSdkPackage.version}`);
+        const wallet = await getWallet();
+        console.log('Wallet loaded:', wallet ? 'SUCCESS' : 'FAILED');
+        const client = (await RandomClient.builder())
+            .withWallet(wallet)
+            .withAOConfig(AO_CONFIG)
+            .withProcessId("1nTos_shMV8HlC7f2svZNZ3J09BROKCTK8DyvkrzLag")
+            .withTokenAOConfig(AO_CONFIG)
+            .withTokenProcessId("rPpsRk9Rm8_SJ1JF8m9_zjTalkv9Soaa_5U0tYUloeY")
+            .build();
+        
+        randomClientInstance = client;
+        lastInitTime = Date.now();
+        
+        if (isFirst) {
+            firstInitializationComplete = true;
         }
-    })();
-    
-    // Store the promise for potential awaiting
-    initPromise = initializationPromise;
-    
-    if (awaitCompletion) {
-        return await initializationPromise;
-    } else {
-        // Run in background, return old instance if available
-        initializationPromise.catch(err => {
-            logger.error('[RandomClient] Background initialization failed:', err);
-        });
         
-        if (randomClientInstance) {
-            return randomClientInstance;
-        } else {
-            // No old instance available, must await
-            logger.warn('[RandomClient] No existing instance available - forcing await of initialization');
-            return await initializationPromise;
+        return client;
+        
+    } catch (err) {
+        if (isFirst) {
+            throw new Error(`Critical: Random client initialization failed: ${err}`);
         }
+        throw err;
+    } finally {
+        isInitializing = false;
+        initializationPromise = null;
     }
 }
 
-// Add a method to explicitly refresh the client if needed
+// Force refresh the client
 export async function refreshRandomClient(): Promise<RandomClient> {
-    logger.info('[RandomClient] Explicit refresh requested');
     randomClientInstance = null;
     lastInitTime = 0;
     isInitializing = false;
-    initPromise = null;
-    // Don't reset first initialization flags - this is just a refresh
-    return await initializeRandomClientWithLogging(true);
+    initializationPromise = null;
+    return await initializeRandomClient();
 }
 
 // Step 2: Process Challenge Requests (Database selection & assigning is atomic)
@@ -205,84 +166,26 @@ export async function processChallengeRequests(
     logger.info(`${parentLogId} Processing up to ${requestIds.length} requests.`);
 
     try {
-        await client.query('BEGIN'); // Start transaction
-
-        logger.debug(`${parentLogId} Fetching existing request mappings.`);
-
-        // Fetch already assigned request_id -> dbId mappings
-        const existingMappingsRes = await client.query(
-            `SELECT request_id FROM time_lock_puzzles 
-             WHERE request_id = ANY($1) 
-             FOR UPDATE SKIP LOCKED`,
-            [requestIds]
-        );
-
-        const existingRequestIds = new Set(existingMappingsRes.rows.map(row => row.request_id));
-        logger.debug(`${parentLogId} Found ${existingRequestIds.size} already mapped requests.`);
-
-        // Find only the unmapped requests (requestIds not in existingRequestIds)
-        const unmappedRequestIds = requestIds.filter(requestId => !existingRequestIds.has(requestId));
-        logger.debug(`${parentLogId} Unmapped requests: ${unmappedRequestIds.length}`);
-
-        let mappedEntries: { requestId: string, dbId: number }[] = [];
-
-        if (unmappedRequestIds.length > 0) {
-            logger.debug(`${parentLogId} Fetching available DB entries.`);
-            const dbRes = await client.query(
-                `SELECT id FROM time_lock_puzzles 
-                 WHERE request_id IS NULL 
-                 ORDER BY id ASC 
-                 LIMIT $1 
-                 FOR UPDATE SKIP LOCKED`,
-                [unmappedRequestIds.length]
-            );
-
-            const availableDbEntries = dbRes.rows.map(row => row.id);
-            logger.debug(`${parentLogId} Found ${availableDbEntries.length} available DB entries.`);
-
-            if (availableDbEntries.length > 0) {
-                const numMappings = Math.min(unmappedRequestIds.length, availableDbEntries.length);
-
-                for (let i = 0; i < numMappings; i++) {
-                    await client.query(
-                        `UPDATE time_lock_puzzles 
-                         SET request_id = $1 
-                         WHERE id = $2`,
-                        [unmappedRequestIds[i], availableDbEntries[i]]
-                    );
-                    mappedEntries.push({ requestId: unmappedRequestIds[i], dbId: availableDbEntries[i] });
-                    logger.debug(`${parentLogId} Assigned Request ID ${unmappedRequestIds[i]} to DB Entry ${availableDbEntries[i]}.`);
-                }
-            } else {
-                logger.warn(`${parentLogId} No available DB entries for unmapped requests.`);
-            }
-        }
+        // Use db_tools function to assign request IDs to database entries
+        const mappedEntries = await assignRequestIdsToEntries(client, requestIds);
+        logger.info(`${parentLogId} Assigned ${mappedEntries.length} request IDs to database entries.`);
 
-        // Collect all request IDs (previously mapped + newly mapped)
-        const allRequestIds = [...existingRequestIds, ...mappedEntries.map(entry => entry.requestId)];
-
-        if (allRequestIds.length === 0) {
-            logger.info(`${parentLogId} No requests to process. Committing transaction.`);
-            await client.query('COMMIT');
+        if (mappedEntries.length === 0) {
+            logger.info(`${parentLogId} No requests to process.`);
             return;
         }
 
-        await client.query('COMMIT'); // Commit all updates at once
-        logger.info(`${parentLogId} Committed all changes. Now fulfilling challenges.`);
-
         // Call fulfillRandomChallenge for all request IDs
         await Promise.all(
-            allRequestIds.map(requestId =>
-                fulfillRandomChallenge(client, requestId, parentLogId)
-                    .catch(error => logger.error(`${parentLogId} Error fulfilling challenge for Request ID ${requestId}:`, error))
+            mappedEntries.map(entry =>
+                fulfillRandomChallenge(client, entry.requestId, parentLogId)
+                    .catch(error => logger.error(`${parentLogId} Error fulfilling challenge for Request ID ${entry.requestId}:`, error))
             )
         );
 
         logger.info(`${parentLogId} All challenges fulfilled`);
     } catch (error: any) {
         logger.error(`${parentLogId} Error in processChallengeRequests:`, error);
-        await client.query('ROLLBACK'); // Rollback on failure
-
         logger.error(`SQL State: ${error.code}, Message: ${error.message}`);
     }
 }
@@ -320,71 +223,22 @@ export async function cleanupFulfilledEntries(
 ): Promise<void> {
     logger.info(`${parentLogId} Step 4: Checking for fulfilled entries no longer in use.`);
 
-    const now = new Date();
-    const cutoffTime = new Date(now.getTime() - COMPLETION_RETENTION_PERIOD_MS);
-
     try {
-        await client.query('BEGIN');
-
-        // Fetch all entries with a request_id
-        const result = await client.query(`
-            SELECT id, request_id, detected_completed 
-            FROM time_lock_puzzles 
-            WHERE request_id IS NOT NULL
-        `);
-
-        let markForDeletion: string[] = [];
-        let markAsCompleted: string[] = [];
-
-        for (const row of result.rows) {
-            const { id, request_id, detected_completed } = row;
-
-            // Check if this request is still active in challenge or output
-            const isStillInChallenge = openRequests.activeChallengeRequests?.request_ids.includes(request_id);
-            const isStillInOutput = openRequests.activeOutputRequests?.request_ids.includes(request_id);
-
-            if (!isStillInChallenge && !isStillInOutput) {
-                if (!detected_completed) {
-                    // Mark it for deletion by setting detected_completed timestamp
-                    markAsCompleted.push(id);
-                } else if (new Date(detected_completed) < cutoffTime) {
-                    // If already marked and older than retention period, delete it
-                    markForDeletion.push(id);
-                }
-            }
-        }
-
-        // Mark entries as completed
-        if (markAsCompleted.length > 0) {
-            await client.query(`
-                UPDATE time_lock_puzzles
-                SET detected_completed = NOW()
-                WHERE id = ANY($1)
-            `, [markAsCompleted]);
-            logger.debug(`${parentLogId} Marked ${markAsCompleted.length} entries as completed.`);
-        }
-
-        // Delete old completed entries 
-        if (markForDeletion.length > 0) {
-            await client.query(`
-                DELETE FROM rsa_keys
-                WHERE id IN (
-                    SELECT rsa_id FROM time_lock_puzzles WHERE id = ANY($1)
-                );
-            `, [markForDeletion]);
-
-            await client.query(`
-                DELETE FROM time_lock_puzzles
-                WHERE id = ANY($1);
-            `, [markForDeletion]);
-
-            logger.info(`${parentLogId} Deleted ${markForDeletion.length} old completed entries and corresponding RSA keys.`);
-        }
+        const activeChallengeRequestIds = openRequests.activeChallengeRequests?.request_ids || [];
+        const activeOutputRequestIds = openRequests.activeOutputRequests?.request_ids || [];
+        
+        // Use db_tools function for cleanup
+        const result = await cleanupFulfilledEntriesAdvanced(
+            client,
+            activeChallengeRequestIds,
+            activeOutputRequestIds,
+            COMPLETION_RETENTION_PERIOD_MS
+        );
 
-        await client.query('COMMIT');
+        logger.debug(`${parentLogId} Marked ${result.markedCompleted} entries as completed.`);
+        logger.info(`${parentLogId} Deleted ${result.deleted} old completed entries and corresponding RSA keys.`);
     } catch (error) {
         logger.error(`${parentLogId} Error in cleanupFulfilledEntries:`, error);
-        await client.query('ROLLBACK');
     }
 
     logger.info(`${parentLogId} Step 4 completed.`);
@@ -460,7 +314,7 @@ export async function getProviderRequests(PROVIDER_ID: string, parentLogId: stri
         try {
             client = await getRandomClient();
             if (!client) {
-                throw new Error('Failed to initialize RandomClient');
+                throw new Error('Failed to initialize RandomClient1');
             }
         } catch (clientError) {
             logger.error(`${parentLogId} Failed to initialize RandomClient:`, clientError);
@@ -637,11 +491,8 @@ export async function getProviderRequests(PROVIDER_ID: string, parentLogId: stri
 // Function to check and fetch database entries as needed
 export async function checkAndFetchIfNeeded(client: Client) {
     try {
-        // Query current count of usable DB entries
-        const res = await client.query(
-            'SELECT COUNT(*) AS count FROM time_lock_puzzles WHERE request_id IS NULL'
-        );
-        const currentCount = parseInt(res.rows[0].count, 10);
+        // Use db_tools function to get count of usable DB entries
+        const currentCount = await getUsableEntriesCount(client);
         logger.info(`Total usable DB entries: ${currentCount}`);
 
         switch (current_onchain_random) {
@@ -782,24 +633,18 @@ async function fulfillRandomChallenge(client: Client, requestId: string, parentL
             // Get a fresh client for each attempt
             randomClient = await getRandomClient();
             if (!randomClient) {
-                throw new Error('Failed to initialize RandomClient');
+                throw new Error('Failed to initialize RandomClient2');
             }
 
-            // Fetch the necessary details from the database using requestId
-            const res = await client.query(
-                `SELECT id, modulus, x 
-                 FROM time_lock_puzzles 
-                 WHERE request_id = $1`,
-                [requestId]
-            );
-
-            if (!res.rowCount) {
+            // Use db_tools function to get puzzle data
+            const puzzleData = await getPuzzleDataForChallenge(client, requestId);
+            
+            if (!puzzleData) {
                 logger.error(`${logPrefix} No database entry found for request`);
                 return;
             }
 
-
-            const { id: dbId, modulus, x: input } = res.rows[0];
+            const { id: dbId, modulus, x: input } = puzzleData;
             
             if (!modulus || !input) {
                 throw new Error('Missing required fields in database entry');
@@ -881,29 +726,18 @@ async function fulfillRandomOutput(client: Client, requestId: string, parentLogI
             // Get a fresh client for each attempt
             randomClient = await getRandomClient();
             if (!randomClient) {
-                throw new Error('Failed to initialize RandomClient');
+                throw new Error('Failed to initialize RandomClient3');
             }
 
-            // Fetch the output and proof from the database using the requestId
-            const res = await client.query(
-                `SELECT 
-                    tlp.id, 
-                    tlp.y AS output, 
-                    rk.p, 
-                    rk.q 
-                FROM time_lock_puzzles tlp
-                JOIN rsa_keys rk ON tlp.rsa_id = rk.id
-                WHERE tlp.request_id = $1`,
-                [requestId]
-            );
-
-            if (!res.rowCount) {
+            // Use db_tools function to get puzzle data for output
+            const puzzleData = await getPuzzleDataForOutput(client, requestId);
+            
+            if (!puzzleData) {
                 logger.error(`${logPrefix} No database entry found for request`);
                 return;
             }
 
-
-            const { id: dbId, output, p: rsaP, q: rsaQ } = res.rows[0];
+            const { id: dbId, output, rsaP, rsaQ } = puzzleData;
             
             if (!output || !rsaP || !rsaQ) {
                 throw new Error('Missing required fields in database entry');
@@ -991,22 +825,6 @@ export async function gracefulShutdown() {
         logger.debug(`${logPrefix} Error details:`, error);
         monitoring.incrementErrorCount();
     } finally {
-        // // Ensure the client is properly cleaned up
-        // if (randomClient) {
-        //     try {
-        //         if (typeof (randomClient as any).disconnect === 'function') {
-        //             await (randomClient as any).disconnect().catch((e: Error) => 
-        //                 logger.warn(`${logPrefix} Error disconnecting client:`, e)
-        //             );
-        //         }
-        //     } catch (e) {
-        //         logger.warn(`${logPrefix} Error during client cleanup:`, e);
-        //     }
-        // }
-        
-        // // Clear the client instance to ensure a fresh start if the process continues
-        // randomClientInstance = null;
-
-        
+   
     }
 }
diff --git a/orchestrator/src/walletUtils.ts b/orchestrator/src/walletUtils.ts
index 03472eb..27c3285 100644
--- a/orchestrator/src/walletUtils.ts
+++ b/orchestrator/src/walletUtils.ts
@@ -17,7 +17,6 @@ const arweave = Arweave.init({
 
 // Global wallet storage
 let globalWallet: JWKInterface | null = null;
-let walletSource: 'seed_phrase' | 'json' | null = null;
 
 /**
  * Update or add a variable to the .env file
@@ -29,6 +28,12 @@ async function updateEnvVariable(key: string, value: string): Promise<void> {
         const envPath = path.join('/host-compose', '.env');
         let envContent = '';
         
+        // Create directory if it doesn't exist
+        const envDir = path.dirname(envPath);
+        if (!fs.existsSync(envDir)) {
+            fs.mkdirSync(envDir, { recursive: true });
+        }
+        
         // Read existing content if file exists
         if (fs.existsSync(envPath)) {
             envContent = fs.readFileSync(envPath, 'utf8');
@@ -54,6 +59,47 @@ async function updateEnvVariable(key: string, value: string): Promise<void> {
     }
 }
 
+/**
+ * Update or add a variable to the .env file using single quotes
+ * @param key Environment variable key
+ * @param value Environment variable value
+ */
+async function updateEnvVariableWithSingleQuotes(key: string, value: string): Promise<void> {
+    try {
+        const envPath = path.join('/host-compose', '.env');
+        let envContent = '';
+        
+        // Create directory if it doesn't exist
+        const envDir = path.dirname(envPath);
+        if (!fs.existsSync(envDir)) {
+            fs.mkdirSync(envDir, { recursive: true });
+        }
+        
+        // Read existing content if file exists
+        if (fs.existsSync(envPath)) {
+            envContent = fs.readFileSync(envPath, 'utf8');
+        }
+        
+        // Check if the variable already exists
+        const regex = new RegExp(`^${key}\\s*=.*$`, 'm');
+        const newLine = `${key} = '${value}'`;
+        
+        if (regex.test(envContent)) {
+            // Replace existing variable
+            envContent = envContent.replace(regex, newLine);
+        } else {
+            // Add new variable
+            envContent += (envContent && !envContent.endsWith('\n') ? '\n' : '') + newLine + '\n';
+        }
+        
+        // Write updated content back to file
+        fs.writeFileSync(envPath, envContent, 'utf8');
+        
+    } catch (error) {
+        throw new Error(`Failed to update ${key} in .env file: ${error}`);
+    }
+}
+
 /**
  * Credits to arweave.app for the mnemonic wallet generation
  *
@@ -156,159 +202,114 @@ export function isValidMnemonic(mnemonic: string): number {
 }
 
 /**
- * Check for missing wallet configuration and generate seed phrase if needed
- * Creates or appends to .env file in docker-compose directory
+ * Initialize wallet configuration - loads existing or creates new
  */
 export async function ensureWalletConfiguration(): Promise<void> {
-    const hasSeedPhrase = !!process.env.SEED_PHRASE && 
-        process.env.SEED_PHRASE !== "Create a NEW wallet and enter the 12 - 24 words here";
-    const hasWalletJson = !!process.env.WALLET_JSON;
-
-    // If either configuration exists in environment variables, we're good
-    if (hasSeedPhrase || hasWalletJson) {
+    // Try existing wallet JSON first
+    let walletJson = loadWalletJson();
+    if (walletJson) {
+        const wallet = JSON.parse(walletJson);
+        const providerId = await arweave.wallets.jwkToAddress(wallet);
+        process.env.WALLET_JSON = walletJson;
+        process.env.PROVIDER_ID = providerId;
+        await updateEnvVariable('PROVIDER_ID', providerId);
+        return;
+    }
+    
+    // Try existing seed phrase
+    let seedPhrase = loadSeedPhrase();
+    if (seedPhrase) {
+        const wallet = await jwkFromMnemonic(seedPhrase);
+        walletJson = JSON.stringify(wallet);
+        const providerId = await arweave.wallets.jwkToAddress(wallet);
+        
+        await updateEnvVariableWithSingleQuotes('WALLET_JSON', walletJson);
+        await updateEnvVariable('PROVIDER_ID', providerId);
+        
+        process.env.WALLET_JSON = walletJson;
+        process.env.PROVIDER_ID = providerId;
         return;
     }
+    
+    // Create new wallet
+    seedPhrase = generateMnemonic(128);
+    const wallet = await jwkFromMnemonic(seedPhrase);
+    walletJson = JSON.stringify(wallet);
+    const providerId = await arweave.wallets.jwkToAddress(wallet);
+    
+    await updateEnvVariable('SEED_PHRASE', seedPhrase);
+    await updateEnvVariableWithSingleQuotes('WALLET_JSON', walletJson);
+    await updateEnvVariable('PROVIDER_ID', providerId);
+    
+    process.env.SEED_PHRASE = seedPhrase;
+    process.env.WALLET_JSON = walletJson;
+    process.env.PROVIDER_ID = providerId;
+    
+    console.log(`New wallet created. Seed phrase: ${seedPhrase}`);
+}
 
-    // Fallback: Check if seed phrase exists in the mounted .env file
+/**
+ * Load wallet JSON from environment or .env file
+ */
+function loadWalletJson(): string | null {
+    if (process.env.WALLET_JSON) {
+        return process.env.WALLET_JSON;
+    }
+    
     const envPath = path.join('/host-compose', '.env');
     if (fs.existsSync(envPath)) {
-        try {
-            const envContent = fs.readFileSync(envPath, 'utf8');
-            const seedPhraseMatch = envContent.match(/^SEED_PHRASE="(.+)"$/m);
-            
-            if (seedPhraseMatch && seedPhraseMatch[1]) {
-                const existingSeedPhrase = seedPhraseMatch[1];
-                if (existingSeedPhrase !== "Create a NEW wallet and enter the 12 - 24 words here") {
-                    process.env.SEED_PHRASE = existingSeedPhrase;
-                    return;
-                }
-            }
-        } catch (error) {
-            // Ignore read errors
+        const envContent = fs.readFileSync(envPath, 'utf8');
+        const walletJsonMatch = envContent.match(/^WALLET_JSON\s*=\s*'(.+)'$/ms);
+        if (walletJsonMatch) {
+            return walletJsonMatch[1];
         }
     }
+    
+    return null;
+}
 
-    try {
-        // Generate a 12-word BIP39-compliant mnemonic
-        const mnemonic = generateMnemonic(128); // 128 bits = 12 words
-        
-        // Validate the generated mnemonic
-        if (!validateMnemonic(mnemonic)) {
-            throw new Error("Generated mnemonic failed validation");
-        }
-
-        // Determine the .env file path (write to host directory via volume mount)
-        const envPath = path.join('/host-compose', '.env');
-        
-        // Prepare the seed phrase entry
-        const seedPhraseEntry = `SEED_PHRASE="${mnemonic}"`;
-        
-        // Check if .env file exists
-        let envContent = '';
-        if (fs.existsSync(envPath)) {
-            envContent = fs.readFileSync(envPath, 'utf8');
-        }
-
-        // Append the seed phrase to the file
-        const newContent = envContent + (envContent && !envContent.endsWith('\n') ? '\n' : '') + seedPhraseEntry + '\n';
-        fs.writeFileSync(envPath, newContent, 'utf8');
-        
-        // Set the environment variable for the current process
-        process.env.SEED_PHRASE = mnemonic;
-        
-        console.warn("IMPORTANT: Please backup your seed phrase securely. This is the only way to recover your wallet!");
-        
-        // Generate and save the provider ID
-        try {
-            const wallet = await jwkFromMnemonic(mnemonic);
-            const providerId = await arweave.wallets.jwkToAddress(wallet);
-            await updateEnvVariable('PROVIDER_ID', providerId);
-            process.env.PROVIDER_ID = providerId;
-        } catch (error) {
-            throw new Error(`Failed to generate and save provider ID: ${error}`);
+/**
+ * Load seed phrase from environment or .env file
+ */
+function loadSeedPhrase(): string | null {
+    if (process.env.SEED_PHRASE && process.env.SEED_PHRASE !== "Create a NEW wallet and enter the 12 - 24 words here") {
+        return process.env.SEED_PHRASE;
+    }
+    
+    const envPath = path.join('/host-compose', '.env');
+    if (fs.existsSync(envPath)) {
+        const envContent = fs.readFileSync(envPath, 'utf8');
+        const seedPhraseMatch = envContent.match(/^SEED_PHRASE="(.+)"$/m);
+        if (seedPhraseMatch && seedPhraseMatch[1] !== "Create a NEW wallet and enter the 12 - 24 words here") {
+            return seedPhraseMatch[1];
         }
-        
-    } catch (error) {
-        throw new Error(`Wallet configuration setup failed: ${error}`);
     }
+    
+    return null;
 }
 
+
 /**
- * Initialize wallet from environment variables
- * Prioritizes SEED_PHRASE over WALLET_JSON if both are present
- * 
- * @returns JWK wallet object
+ * Get the wallet JWK interface
  */
-export async function initializeWallet(): Promise<JWKInterface> {
-  // If wallet is already initialized, return it
-  if (globalWallet) {
-    return globalWallet;
-  }
-
-  const hasSeedPhrase = !!process.env.SEED_PHRASE;
-  const hasWalletJson = !!process.env.WALLET_JSON;
-
-  if (!hasSeedPhrase && !hasWalletJson) {
-    throw new Error("No wallet configuration found. Please provide either SEED_PHRASE or WALLET_JSON in environment variables.");
-  }
-
-  let wallet: JWKInterface;
-
-  // Try to load wallet from seed phrase if available
-  if (hasSeedPhrase) {
-    try {
-      const seedPhrase = process.env.SEED_PHRASE!;
-      
-      const validationResult = isValidMnemonic(seedPhrase);
-      
-      if (!validationResult) {
-        throw new Error("Invalid seed phrase format");
-      }
-      
-      wallet = await jwkFromMnemonic(seedPhrase);
-      const seedPhraseAddress = await arweave.wallets.jwkToAddress(wallet);
-      
-      walletSource = 'seed_phrase';
-      globalWallet = wallet;
-      
-      // Set PROVIDER_ID in .env file
-      try {
-        await updateEnvVariable('PROVIDER_ID', seedPhraseAddress);
-        process.env.PROVIDER_ID = seedPhraseAddress;
-      } catch (error) {
-        // Ignore env file errors in standalone mode
-      }
-      
-    } catch (error) {
-      // Fall back to JSON if available
-      if (!hasWalletJson) {
-        throw error;
-      }
+export async function getWallet(): Promise<JWKInterface> {
+    if (globalWallet) {
+        return globalWallet;
     }
-  }
-
-  // If we haven't successfully initialized the wallet from seed phrase, try JSON
-  if (!globalWallet && hasWalletJson) {
-    try {
-      wallet = JSON.parse(process.env.WALLET_JSON!);
-      const jsonAddress = await arweave.wallets.jwkToAddress(wallet);
-      
-      walletSource = 'json';
-      globalWallet = wallet;
-      
-      // Set PROVIDER_ID in .env file
-      try {
-        await updateEnvVariable('PROVIDER_ID', jsonAddress);
-        process.env.PROVIDER_ID = jsonAddress;
-      } catch (error) {
-        // Ignore env file errors in standalone mode
-      }
-    } catch (error) {
-      throw new Error(`Failed to initialize wallet from WALLET_JSON: ${error}`);
+    
+    if (!process.env.WALLET_JSON) {
+        throw new Error('WALLET_JSON not found. Call ensureWalletConfiguration first.');
     }
-  }
+    
+    globalWallet = JSON.parse(process.env.WALLET_JSON);
+    return globalWallet!;
+}
 
-  return globalWallet!;
+/**
+ * Initialize wallet from environment variables (DEPRECATED - use getWallet instead)
+ */
+export async function initializeWallet(): Promise<JWKInterface> {
+  return await getWallet();
 }
 
 /**
@@ -317,19 +318,10 @@ export async function initializeWallet(): Promise<JWKInterface> {
  * @returns Provider ID/wallet address
  */
 export async function getWalletAddress(): Promise<string> {
-  const wallet = await initializeWallet();
+  const wallet = await getWallet();
   return await arweave.wallets.jwkToAddress(wallet);
 }
 
-/**
- * Get the wallet for signing transactions
- * 
- * @returns JWK wallet object
- */
-export async function getWallet(): Promise<JWKInterface> {
-  return await initializeWallet();
-}
-
 /**
  * CLI function to get address from mnemonic
  * Usage: npx ts-node walletUtils.ts "word1 word2 ... word12"
